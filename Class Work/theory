        ООП в PHP

2 основные парадигмы программирования:
1. процедурно-ориентированное программирование. вся логика выносится в процедуры.
каждая из которых вызывает последующую и тд.
Основные минусы:
- низкий уровень абстракции;
- эффект спагетти, когда одна функция вызывает одну, одна другую и тд.
- монолитность кода. сложно подменить какой-либо модуль. много правок при изменении
- сложность в поддержке, из-за выше перечисленных факторов.
2. ООП строится на понятии объектов.
Самым первым языком который внес идеалогию ООП  - Simula 67, следующим стал Smalltalk 80
В 1983 C++ - положивший фундамент всему ООП, именно в нем зародились понятия
классов, методов, наследования. В 2014 практически все языки в той или иной степени
стали использовать ООП.

    Основная концепция.
Все представляет собой объекты, объект имеет св-ва и характеристики, которые его
описывают. Объекты выполняют действия(имеют методы).
Программа связывает (обеспечивает общение)объекты.
Т.е. объект - это некоторая уникальная единица, имеющая свои переменные и функции,
которые эти переменные обрабатывают.
В классическом ООП существует понятие класса. Класс - разновидность пользовательского
типа данных, характеризуемая способом его построения. Своего рода эскиз.
Описывает как будет устроен объект, какие дейсвтия он может выполнять.
Классы обязательно имеют имя, свойства, и описывают поведение объекта, т.е. содержат
набор тех ф-ций, которые относятся к объекту данного класса.
Экземпляр класса - объект созданный с помощью данного класса.

 ООП стоит на 3-х принципах: Инкапсуляция, наследование и полиморфизм.
1. Инкапсуляция - сложная логика объекта скрыта внутри него и недоступна извне.
Мы не знаем что и как происходит в объекте, мы просто пользуемся его интерфейсом, внутри
приватное, то что скрыто от внешнего мира.
2. Наследование - механизм, который позволяет наследникам содержать в себе св-ва
и методы, описываемые в другом классе. Допустим есть класс транспорт: который имеет
в себе 2 класса: водный и наземный: наземный в свою очередь имеет след классы и тд.
3 Полиморфизм - способность объекта вести себя по-разному, в зависимости от ситуации
и реагировать на определенное действие строго специфичным для себя образом.
На практике это означает следующее. Объект наследник без труда может заменить объект
родитель, т.к. имеет весь тот фунционал. Объект заменивший родитель, будет вести себя
характерным лично для себя образом.
Переопределение, мы пишем логику у родителя, П. может позволять описывать ту же логику
у наследника, но она может вести себя по-другому.

        Классы в PHP

class Name {
private $name="anonim"}

Существует 3 модификатора:
private - доступен только внутри класса, извне к нему достучаться нельзя
public - можно достучаться из любой точки программы
protected - только из этого класса и из всех его наследников.

По-умолчанию все модификаторы - public. Хорошим тоном является установка модификаторов
явным образом, а также устанавливать модфикаторы в private, а достучаться к этим св-вам
можно через методы (Get,Set).

public function getName(){
    return $this->name;
}

Создание объекта класса
$u = new User();
echo $u->getName();

Методы get set устанавливаеются программно через Alt+Insert (выбираем Getters Setters),
выбираем необходимые поля и они устанавливаются автоматом.

    Конструктор
Конструктор вызывается в тот момент, когда на основе класса создается новый объект.
public function __construct(string $name, string $pass){
    $this->name = $name;
    $this->pass = $pass;
}
Особенностью php 7.1. является возможность установки в конструкторе параметры по умолчанию
public function __construct(?string $name="anonim", ?string $pass=""){
    $this->name = $name;
    $this->pass = $pass;
}
Т.е. при вызове конструктора, мы теперь можем даже не передавать значения
параметров, они подставятся из "по-умолчанию".

Возможно создание переменных, которые будут принадлежать самому классу.
public static $VAR = "value";
Можем снаружи к ней достучаться User::$VAR;
Ее можно сделать приватной, и использовать ее только внутри класса.

    Статический метод

Public static function f(){
    return ":";
}

Теперь мы эту функцию можем использовать внутри самого класса:
self::f
Статические методы не имеют this и хранятся в одном экземпляре на весь класс,
если мы делаем обычный метод, то его код будет помещен в каждый объект класса,
а данный метод мы сможем вызывать на самом классе, не создавая его экземпляр, если
это необходимо.

    Сравнение объектов

Это не сравнение их полей. Объекты сравниваются по ссылке, т.е. только 2 одинаковых
объекта дадут тру.
Если необхоимо сравнивать объекты по их внутренним объектам, то надо создавать
отдельный метод, где можно будет перебрать значения полей 2-х и более объектов.

Объекты присваиваются по ссылке, следовательно
$u = new User();
$f = $u;
То изменения, которые произойдут в $f првиедут к изменениям и в $u. Т.к. обе эти
переменные - это просто указатель на объект.
